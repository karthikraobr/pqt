// Code generated by pqt.
// source: cmd/appg/main.go
// DO NOT EDIT!
package main

import (
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/go-kit/kit/log"
	"github.com/golang/protobuf/ptypes"
	"github.com/piotrkowalczuk/ntypes"
	"github.com/piotrkowalczuk/pqcomp"
	"github.com/piotrkowalczuk/pqt/pqtgo"
	"github.com/piotrkowalczuk/qtypes"
)

const (
	tableCategory                             = "example.category"
	tableCategoryColumnContent                = "content"
	tableCategoryColumnCreatedAt              = "created_at"
	tableCategoryColumnID                     = "id"
	tableCategoryColumnName                   = "name"
	tableCategoryColumnParentID               = "parent_id"
	tableCategoryColumnUpdatedAt              = "updated_at"
	tableCategoryConstraintPrimaryKey         = "example.category_id_pkey"
	tableCategoryConstraintParentIDForeignKey = "example.category_parent_id_fkey"
)

var (
	tableCategoryColumns = []string{
		tableCategoryColumnContent,
		tableCategoryColumnCreatedAt,
		tableCategoryColumnID,
		tableCategoryColumnName,
		tableCategoryColumnParentID,
		tableCategoryColumnUpdatedAt,
	}
)

type categoryEntity struct {
	// content ...
	content string
	// createdAt ...
	createdAt time.Time
	// id ...
	id int64
	// name ...
	name string
	// parentID ...
	parentID *ntypes.Int64
	// updatedAt ...
	updatedAt *time.Time
	// childCategory ...
	childCategory []*categoryEntity
	// parentCategory ...
	parentCategory *categoryEntity
	// packages ...
	packages []*packageEntity
}

func (e *categoryEntity) prop(cn string) (interface{}, bool) {
	switch cn {
	case tableCategoryColumnContent:
		return &e.content, true
	case tableCategoryColumnCreatedAt:
		return &e.createdAt, true
	case tableCategoryColumnID:
		return &e.id, true
	case tableCategoryColumnName:
		return &e.name, true
	case tableCategoryColumnParentID:
		return &e.parentID, true
	case tableCategoryColumnUpdatedAt:
		return &e.updatedAt, true
	default:
		return nil, false
	}
}
func (e *categoryEntity) props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// categoryIterator is not thread safe.
type categoryIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *categoryIterator) Next() bool {
	return i.rows.Next()
}

func (i *categoryIterator) Close() error {
	return i.rows.Close()
}

func (i *categoryIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *categoryIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper around category method that makes iterator more generic.
func (i *categoryIterator) Ent() (interface{}, error) {
	return i.Category()
}

func (i *categoryIterator) Category() (*categoryEntity, error) {
	var ent categoryEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type categoryCriteria struct {
	offset, limit int64
	sort          map[string]bool
	content       *qtypes.String
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	name          *qtypes.String
	parentID      *qtypes.Int64
	updatedAt     *qtypes.Timestamp
}

func (c *categoryCriteria) WriteComposition(sel string, com *pqtgo.Composer, opt *pqtgo.CompositionOpts) (err error) {

	if err = pqtgo.WriteCompositionQueryString(c.content, tableCategoryColumnContent, com, pqtgo.And); err != nil {
		return
	}

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return err
			}
			switch c.createdAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableCategoryColumnCreatedAt)
					com.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							com.WriteString(", ")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableCategoryColumnCreatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(createdAt1)
					com.WriteString(" AND ")
					com.WriteString(tableCategoryColumnCreatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(createdAt2)
				}
			}
		}
	}

	if err = pqtgo.WriteCompositionQueryInt64(c.id, tableCategoryColumnID, com, &pqtgo.CompositionOpts{
		Joint:  " AND ",
		IsJSON: false,
	}); err != nil {
		return
	}

	if err = pqtgo.WriteCompositionQueryString(c.name, tableCategoryColumnName, com, pqtgo.And); err != nil {
		return
	}

	if err = pqtgo.WriteCompositionQueryInt64(c.parentID, tableCategoryColumnParentID, com, &pqtgo.CompositionOpts{
		Joint:  " AND ",
		IsJSON: false,
	}); err != nil {
		return
	}

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return err
			}
			switch c.updatedAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableCategoryColumnUpdatedAt)
					com.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							com.WriteString(", ")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableCategoryColumnUpdatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(updatedAt1)
					com.WriteString(" AND ")
					com.WriteString(tableCategoryColumnUpdatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(updatedAt2)
				}
			}
		}
	}

	if len(c.sort) > 0 {
		i := 0
		com.WriteString(" ORDER BY ")

		for cn, asc := range c.sort {
			for _, tcn := range tableCategoryColumns {
				if cn == tcn {
					if i > 0 {
						com.WriteString(", ")
					}
					com.WriteString(cn)
					if !asc {
						com.WriteString(" DESC ")
					}
					i++
					break
				}
			}
		}
	}
	if c.offset > 0 {
		if _, err = com.WriteString(" OFFSET "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.offset)
	}
	if c.limit > 0 {
		if _, err = com.WriteString(" LIMIT "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.limit)
	}

	return
}

type categoryPatch struct {
	content   *ntypes.String
	createdAt *time.Time
	name      *ntypes.String
	parentID  *ntypes.Int64
	updatedAt *time.Time
}

type categoryRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func scanCategoryRows(rows *sql.Rows) ([]*categoryEntity, error) {
	var (
		entities []*categoryEntity
		err      error
	)
	for rows.Next() {
		var ent categoryEntity
		err = rows.Scan(
			&ent.content,
			&ent.createdAt,
			&ent.id,
			&ent.name,
			&ent.parentID,
			&ent.updatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *categoryRepositoryBase) count(c *categoryCriteria) (int64, error) {

	com := pqtgo.NewComposer(6)
	buf := bytes.NewBufferString("SELECT COUNT(*) FROM ")
	buf.WriteString(r.table)

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return 0, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	if err := r.db.QueryRow(buf.String(), com.Args()...).Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

func (r *categoryRepositoryBase) find(c *categoryCriteria) ([]*categoryEntity, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return scanCategoryRows(rows)
}
func (r *categoryRepositoryBase) findIter(c *categoryCriteria) (*categoryIterator, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	return &categoryIterator{rows: rows}, nil
}
func (r *categoryRepositoryBase) findOneByID(id int64) (*categoryEntity, error) {
	var (
		ent categoryEntity
	)
	query := `SELECT content,
created_at,
id,
name,
parent_id,
updated_at
 FROM example.category WHERE id = $1`
	err := r.db.QueryRow(query, id).Scan(
		&ent.content,
		&ent.createdAt,
		&ent.id,
		&ent.name,
		&ent.parentID,
		&ent.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &ent, nil
}
func (r *categoryRepositoryBase) insert(e *categoryEntity) (*categoryEntity, error) {
	insert := pqcomp.New(0, 6)
	insert.AddExpr(tableCategoryColumnContent, "", e.content)
	insert.AddExpr(tableCategoryColumnCreatedAt, "", e.createdAt)
	insert.AddExpr(tableCategoryColumnName, "", e.name)
	insert.AddExpr(tableCategoryColumnParentID, "", e.parentID)
	insert.AddExpr(tableCategoryColumnUpdatedAt, "", e.updatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString(" RETURNING ")
			b.WriteString(strings.Join(r.columns, ", "))
		}
	}

	if r.dbg {
		if err := r.log.Log("msg", b.String(), "function", "Insert"); err != nil {
			return nil, err
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.content,
		&e.createdAt,
		&e.id,
		&e.name,
		&e.parentID,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *categoryRepositoryBase) upsert(e *categoryEntity, p *categoryPatch, inf ...string) (*categoryEntity, error) {
	insert := pqcomp.New(0, 6)
	update := insert.Compose(6)
	insert.AddExpr(tableCategoryColumnContent, "", e.content)
	insert.AddExpr(tableCategoryColumnCreatedAt, "", e.createdAt)
	insert.AddExpr(tableCategoryColumnName, "", e.name)
	insert.AddExpr(tableCategoryColumnParentID, "", e.parentID)
	insert.AddExpr(tableCategoryColumnUpdatedAt, "", e.updatedAt)
	if len(inf) > 0 {
		update.AddExpr(tableCategoryColumnContent, "=", p.content)
		update.AddExpr(tableCategoryColumnCreatedAt, "=", p.createdAt)
		update.AddExpr(tableCategoryColumnName, "=", p.name)
		update.AddExpr(tableCategoryColumnParentID, "=", p.parentID)
		update.AddExpr(tableCategoryColumnUpdatedAt, "=", p.updatedAt)
	}

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() > 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
	}
	b.WriteString(" ON CONFLICT ")
	if len(inf) > 0 && update.Len() > 0 {
		b.WriteString(" (")
		for j, i := range inf {
			if j != 0 {
				b.WriteString(", ")
			}
			b.WriteString(i)
		}
		b.WriteString(") ")
		b.WriteString(" DO UPDATE SET ")
		for update.Next() {
			if !update.First() {
				b.WriteString(", ")
			}

			b.WriteString(update.Key())
			b.WriteString(" ")
			b.WriteString(update.Oper())
			b.WriteString(" ")
			b.WriteString(update.PlaceHolder())
		}
	} else {
		b.WriteString(" DO NOTHING ")
	}
	if insert.Len() > 0 {
		if len(r.columns) > 0 {
			b.WriteString(" RETURNING ")
			b.WriteString(strings.Join(r.columns, ", "))
		}
	}

	if r.dbg {
		if err := r.log.Log("msg", b.String(), "function", "Upsert"); err != nil {
			return nil, err
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.content,
		&e.createdAt,
		&e.id,
		&e.name,
		&e.parentID,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *categoryRepositoryBase) updateOneByID(id int64, patch *categoryPatch) (*categoryEntity, error) {
	update := pqcomp.New(1, 6)
	update.AddArg(id)

	update.AddExpr(tableCategoryColumnContent, pqcomp.Equal, patch.content)
	if patch.createdAt != nil {
		update.AddExpr(tableCategoryColumnCreatedAt, pqcomp.Equal, patch.createdAt)

	}
	update.AddExpr(tableCategoryColumnName, pqcomp.Equal, patch.name)
	update.AddExpr(tableCategoryColumnParentID, pqcomp.Equal, patch.parentID)
	if patch.updatedAt != nil {
		update.AddExpr(tableCategoryColumnUpdatedAt, pqcomp.Equal, patch.updatedAt)
	} else {
		update.AddExpr(tableCategoryColumnUpdatedAt, pqcomp.Equal, "NOW()")
	}

	if update.Len() == 0 {
		return nil, errors.New("category update failure, nothing to update")
	}
	query := "UPDATE example.category SET "
	for update.Next() {
		if !update.First() {
			query += ", "
		}

		query += update.Key() + " " + update.Oper() + " " + update.PlaceHolder()
	}
	query += " WHERE id = $1 RETURNING " + strings.Join(r.columns, ", ")
	var e categoryEntity
	err := r.db.QueryRow(query, update.Args()...).Scan(
		&e.content,
		&e.createdAt,
		&e.id,
		&e.name,
		&e.parentID,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &e, nil
}

func (r *categoryRepositoryBase) deleteOneByID(id int64) (int64, error) {
	query := "DELETE FROM example.category WHERE id = $1"

	res, err := r.db.Exec(query, id)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const (
	tablePackage                               = "example.package"
	tablePackageColumnBreak                    = "break"
	tablePackageColumnCategoryID               = "category_id"
	tablePackageColumnCreatedAt                = "created_at"
	tablePackageColumnID                       = "id"
	tablePackageColumnUpdatedAt                = "updated_at"
	tablePackageConstraintCategoryIDForeignKey = "example.package_category_id_fkey"
	tablePackageConstraintPrimaryKey           = "example.package_id_pkey"
)

var (
	tablePackageColumns = []string{
		tablePackageColumnBreak,
		tablePackageColumnCategoryID,
		tablePackageColumnCreatedAt,
		tablePackageColumnID,
		tablePackageColumnUpdatedAt,
	}
)

type packageEntity struct {
	// brk ...
	brk *ntypes.String
	// categoryID ...
	categoryID *ntypes.Int64
	// createdAt ...
	createdAt time.Time
	// id ...
	id int64
	// updatedAt ...
	updatedAt *time.Time
	// category ...
	category *categoryEntity
}

func (e *packageEntity) prop(cn string) (interface{}, bool) {
	switch cn {
	case tablePackageColumnBreak:
		return &e.brk, true
	case tablePackageColumnCategoryID:
		return &e.categoryID, true
	case tablePackageColumnCreatedAt:
		return &e.createdAt, true
	case tablePackageColumnID:
		return &e.id, true
	case tablePackageColumnUpdatedAt:
		return &e.updatedAt, true
	default:
		return nil, false
	}
}
func (e *packageEntity) props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// packageIterator is not thread safe.
type packageIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *packageIterator) Next() bool {
	return i.rows.Next()
}

func (i *packageIterator) Close() error {
	return i.rows.Close()
}

func (i *packageIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *packageIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper around package method that makes iterator more generic.
func (i *packageIterator) Ent() (interface{}, error) {
	return i.Package()
}

func (i *packageIterator) Package() (*packageEntity, error) {
	var ent packageEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type packageCriteria struct {
	offset, limit int64
	sort          map[string]bool
	brk           *qtypes.String
	categoryID    *qtypes.Int64
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	updatedAt     *qtypes.Timestamp
}

func (c *packageCriteria) WriteComposition(sel string, com *pqtgo.Composer, opt *pqtgo.CompositionOpts) (err error) {

	if err = pqtgo.WriteCompositionQueryString(c.brk, tablePackageColumnBreak, com, pqtgo.And); err != nil {
		return
	}

	if err = pqtgo.WriteCompositionQueryInt64(c.categoryID, tablePackageColumnCategoryID, com, &pqtgo.CompositionOpts{
		Joint:  " AND ",
		IsJSON: false,
	}); err != nil {
		return
	}

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return err
			}
			switch c.createdAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnCreatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnCreatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnCreatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnCreatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tablePackageColumnCreatedAt)
					com.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							com.WriteString(", ")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tablePackageColumnCreatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(createdAt1)
					com.WriteString(" AND ")
					com.WriteString(tablePackageColumnCreatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(createdAt2)
				}
			}
		}
	}

	if err = pqtgo.WriteCompositionQueryInt64(c.id, tablePackageColumnID, com, &pqtgo.CompositionOpts{
		Joint:  " AND ",
		IsJSON: false,
	}); err != nil {
		return
	}

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return err
			}
			switch c.updatedAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnUpdatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnUpdatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnUpdatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tablePackageColumnUpdatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tablePackageColumnUpdatedAt)
					com.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							com.WriteString(", ")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tablePackageColumnUpdatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(updatedAt1)
					com.WriteString(" AND ")
					com.WriteString(tablePackageColumnUpdatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(updatedAt2)
				}
			}
		}
	}

	if len(c.sort) > 0 {
		i := 0
		com.WriteString(" ORDER BY ")

		for cn, asc := range c.sort {
			for _, tcn := range tablePackageColumns {
				if cn == tcn {
					if i > 0 {
						com.WriteString(", ")
					}
					com.WriteString(cn)
					if !asc {
						com.WriteString(" DESC ")
					}
					i++
					break
				}
			}
		}
	}
	if c.offset > 0 {
		if _, err = com.WriteString(" OFFSET "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.offset)
	}
	if c.limit > 0 {
		if _, err = com.WriteString(" LIMIT "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.limit)
	}

	return
}

type packagePatch struct {
	brk        *ntypes.String
	categoryID *ntypes.Int64
	createdAt  *time.Time
	updatedAt  *time.Time
}

type packageRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func scanPackageRows(rows *sql.Rows) ([]*packageEntity, error) {
	var (
		entities []*packageEntity
		err      error
	)
	for rows.Next() {
		var ent packageEntity
		err = rows.Scan(
			&ent.brk,
			&ent.categoryID,
			&ent.createdAt,
			&ent.id,
			&ent.updatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *packageRepositoryBase) count(c *packageCriteria) (int64, error) {

	com := pqtgo.NewComposer(5)
	buf := bytes.NewBufferString("SELECT COUNT(*) FROM ")
	buf.WriteString(r.table)

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return 0, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	if err := r.db.QueryRow(buf.String(), com.Args()...).Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

func (r *packageRepositoryBase) find(c *packageCriteria) ([]*packageEntity, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return scanPackageRows(rows)
}
func (r *packageRepositoryBase) findIter(c *packageCriteria) (*packageIterator, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	return &packageIterator{rows: rows}, nil
}
func (r *packageRepositoryBase) findOneByID(id int64) (*packageEntity, error) {
	var (
		ent packageEntity
	)
	query := `SELECT break,
category_id,
created_at,
id,
updated_at
 FROM example.package WHERE id = $1`
	err := r.db.QueryRow(query, id).Scan(
		&ent.brk,
		&ent.categoryID,
		&ent.createdAt,
		&ent.id,
		&ent.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &ent, nil
}
func (r *packageRepositoryBase) insert(e *packageEntity) (*packageEntity, error) {
	insert := pqcomp.New(0, 5)
	insert.AddExpr(tablePackageColumnBreak, "", e.brk)
	insert.AddExpr(tablePackageColumnCategoryID, "", e.categoryID)
	insert.AddExpr(tablePackageColumnCreatedAt, "", e.createdAt)
	insert.AddExpr(tablePackageColumnUpdatedAt, "", e.updatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString(" RETURNING ")
			b.WriteString(strings.Join(r.columns, ", "))
		}
	}

	if r.dbg {
		if err := r.log.Log("msg", b.String(), "function", "Insert"); err != nil {
			return nil, err
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.brk,
		&e.categoryID,
		&e.createdAt,
		&e.id,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *packageRepositoryBase) upsert(e *packageEntity, p *packagePatch, inf ...string) (*packageEntity, error) {
	insert := pqcomp.New(0, 5)
	update := insert.Compose(5)
	insert.AddExpr(tablePackageColumnBreak, "", e.brk)
	insert.AddExpr(tablePackageColumnCategoryID, "", e.categoryID)
	insert.AddExpr(tablePackageColumnCreatedAt, "", e.createdAt)
	insert.AddExpr(tablePackageColumnUpdatedAt, "", e.updatedAt)
	if len(inf) > 0 {
		update.AddExpr(tablePackageColumnBreak, "=", p.brk)
		update.AddExpr(tablePackageColumnCategoryID, "=", p.categoryID)
		update.AddExpr(tablePackageColumnCreatedAt, "=", p.createdAt)
		update.AddExpr(tablePackageColumnUpdatedAt, "=", p.updatedAt)
	}

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() > 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
	}
	b.WriteString(" ON CONFLICT ")
	if len(inf) > 0 && update.Len() > 0 {
		b.WriteString(" (")
		for j, i := range inf {
			if j != 0 {
				b.WriteString(", ")
			}
			b.WriteString(i)
		}
		b.WriteString(") ")
		b.WriteString(" DO UPDATE SET ")
		for update.Next() {
			if !update.First() {
				b.WriteString(", ")
			}

			b.WriteString(update.Key())
			b.WriteString(" ")
			b.WriteString(update.Oper())
			b.WriteString(" ")
			b.WriteString(update.PlaceHolder())
		}
	} else {
		b.WriteString(" DO NOTHING ")
	}
	if insert.Len() > 0 {
		if len(r.columns) > 0 {
			b.WriteString(" RETURNING ")
			b.WriteString(strings.Join(r.columns, ", "))
		}
	}

	if r.dbg {
		if err := r.log.Log("msg", b.String(), "function", "Upsert"); err != nil {
			return nil, err
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.brk,
		&e.categoryID,
		&e.createdAt,
		&e.id,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *packageRepositoryBase) updateOneByID(id int64, patch *packagePatch) (*packageEntity, error) {
	update := pqcomp.New(1, 5)
	update.AddArg(id)

	update.AddExpr(tablePackageColumnBreak, pqcomp.Equal, patch.brk)
	update.AddExpr(tablePackageColumnCategoryID, pqcomp.Equal, patch.categoryID)
	if patch.createdAt != nil {
		update.AddExpr(tablePackageColumnCreatedAt, pqcomp.Equal, patch.createdAt)

	}
	if patch.updatedAt != nil {
		update.AddExpr(tablePackageColumnUpdatedAt, pqcomp.Equal, patch.updatedAt)
	} else {
		update.AddExpr(tablePackageColumnUpdatedAt, pqcomp.Equal, "NOW()")
	}

	if update.Len() == 0 {
		return nil, errors.New("package update failure, nothing to update")
	}
	query := "UPDATE example.package SET "
	for update.Next() {
		if !update.First() {
			query += ", "
		}

		query += update.Key() + " " + update.Oper() + " " + update.PlaceHolder()
	}
	query += " WHERE id = $1 RETURNING " + strings.Join(r.columns, ", ")
	var e packageEntity
	err := r.db.QueryRow(query, update.Args()...).Scan(
		&e.brk,
		&e.categoryID,
		&e.createdAt,
		&e.id,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &e, nil
}

func (r *packageRepositoryBase) deleteOneByID(id int64) (int64, error) {
	query := "DELETE FROM example.package WHERE id = $1"

	res, err := r.db.Exec(query, id)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const (
	tableNews                          = "example.news"
	tableNewsColumnContent             = "content"
	tableNewsColumnContinue            = "continue"
	tableNewsColumnCreatedAt           = "created_at"
	tableNewsColumnID                  = "id"
	tableNewsColumnLead                = "lead"
	tableNewsColumnTitle               = "title"
	tableNewsColumnUpdatedAt           = "updated_at"
	tableNewsConstraintPrimaryKey      = "example.news_id_pkey"
	tableNewsConstraintTitleUnique     = "example.news_title_key"
	tableNewsConstraintTitleLeadUnique = "example.news_title_lead_key"
)

var (
	tableNewsColumns = []string{
		tableNewsColumnContent,
		tableNewsColumnContinue,
		tableNewsColumnCreatedAt,
		tableNewsColumnID,
		tableNewsColumnLead,
		tableNewsColumnTitle,
		tableNewsColumnUpdatedAt,
	}
)

type newsEntity struct {
	// content ...
	content string
	// cont ...
	cont bool
	// createdAt ...
	createdAt time.Time
	// id ...
	id int64
	// lead ...
	lead *ntypes.String
	// title ...
	title string
	// updatedAt ...
	updatedAt *time.Time
	// commentsByNewsTitle ...
	commentsByNewsTitle []*commentEntity
	// comments ...
	comments []*commentEntity
}

func (e *newsEntity) prop(cn string) (interface{}, bool) {
	switch cn {
	case tableNewsColumnContent:
		return &e.content, true
	case tableNewsColumnContinue:
		return &e.cont, true
	case tableNewsColumnCreatedAt:
		return &e.createdAt, true
	case tableNewsColumnID:
		return &e.id, true
	case tableNewsColumnLead:
		return &e.lead, true
	case tableNewsColumnTitle:
		return &e.title, true
	case tableNewsColumnUpdatedAt:
		return &e.updatedAt, true
	default:
		return nil, false
	}
}
func (e *newsEntity) props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// newsIterator is not thread safe.
type newsIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *newsIterator) Next() bool {
	return i.rows.Next()
}

func (i *newsIterator) Close() error {
	return i.rows.Close()
}

func (i *newsIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *newsIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper around news method that makes iterator more generic.
func (i *newsIterator) Ent() (interface{}, error) {
	return i.News()
}

func (i *newsIterator) News() (*newsEntity, error) {
	var ent newsEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type newsCriteria struct {
	offset, limit int64
	sort          map[string]bool
	content       *qtypes.String
	cont          *ntypes.Bool
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	lead          *qtypes.String
	title         *qtypes.String
	updatedAt     *qtypes.Timestamp
}

func (c *newsCriteria) WriteComposition(sel string, com *pqtgo.Composer, opt *pqtgo.CompositionOpts) (err error) {

	if err = pqtgo.WriteCompositionQueryString(c.content, tableNewsColumnContent, com, pqtgo.And); err != nil {
		return
	}
	if c.cont != nil && c.cont.Valid {
		if com.Dirty {
			com.WriteString(" AND ")
		}
		com.Dirty = true
		com.WriteString(tableNewsColumnContinue)
		com.WriteString(" = ")
		com.WritePlaceholder()
		com.Add(c.cont)
	}

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return err
			}
			switch c.createdAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableNewsColumnCreatedAt)
					com.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							com.WriteString(", ")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableNewsColumnCreatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(createdAt1)
					com.WriteString(" AND ")
					com.WriteString(tableNewsColumnCreatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(createdAt2)
				}
			}
		}
	}

	if err = pqtgo.WriteCompositionQueryInt64(c.id, tableNewsColumnID, com, &pqtgo.CompositionOpts{
		Joint:  " AND ",
		IsJSON: false,
	}); err != nil {
		return
	}

	if err = pqtgo.WriteCompositionQueryString(c.lead, tableNewsColumnLead, com, pqtgo.And); err != nil {
		return
	}

	if err = pqtgo.WriteCompositionQueryString(c.title, tableNewsColumnTitle, com, pqtgo.And); err != nil {
		return
	}

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return err
			}
			switch c.updatedAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableNewsColumnUpdatedAt)
					com.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							com.WriteString(", ")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableNewsColumnUpdatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(updatedAt1)
					com.WriteString(" AND ")
					com.WriteString(tableNewsColumnUpdatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(updatedAt2)
				}
			}
		}
	}

	if len(c.sort) > 0 {
		i := 0
		com.WriteString(" ORDER BY ")

		for cn, asc := range c.sort {
			for _, tcn := range tableNewsColumns {
				if cn == tcn {
					if i > 0 {
						com.WriteString(", ")
					}
					com.WriteString(cn)
					if !asc {
						com.WriteString(" DESC ")
					}
					i++
					break
				}
			}
		}
	}
	if c.offset > 0 {
		if _, err = com.WriteString(" OFFSET "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.offset)
	}
	if c.limit > 0 {
		if _, err = com.WriteString(" LIMIT "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.limit)
	}

	return
}

type newsPatch struct {
	content   *ntypes.String
	cont      *ntypes.Bool
	createdAt *time.Time
	lead      *ntypes.String
	title     *ntypes.String
	updatedAt *time.Time
}

type newsRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func scanNewsRows(rows *sql.Rows) ([]*newsEntity, error) {
	var (
		entities []*newsEntity
		err      error
	)
	for rows.Next() {
		var ent newsEntity
		err = rows.Scan(
			&ent.content,
			&ent.cont,
			&ent.createdAt,
			&ent.id,
			&ent.lead,
			&ent.title,
			&ent.updatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *newsRepositoryBase) count(c *newsCriteria) (int64, error) {

	com := pqtgo.NewComposer(7)
	buf := bytes.NewBufferString("SELECT COUNT(*) FROM ")
	buf.WriteString(r.table)

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return 0, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	if err := r.db.QueryRow(buf.String(), com.Args()...).Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

func (r *newsRepositoryBase) find(c *newsCriteria) ([]*newsEntity, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return scanNewsRows(rows)
}
func (r *newsRepositoryBase) findIter(c *newsCriteria) (*newsIterator, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	return &newsIterator{rows: rows}, nil
}
func (r *newsRepositoryBase) findOneByID(id int64) (*newsEntity, error) {
	var (
		ent newsEntity
	)
	query := `SELECT content,
continue,
created_at,
id,
lead,
title,
updated_at
 FROM example.news WHERE id = $1`
	err := r.db.QueryRow(query, id).Scan(
		&ent.content,
		&ent.cont,
		&ent.createdAt,
		&ent.id,
		&ent.lead,
		&ent.title,
		&ent.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &ent, nil
}
func (r *newsRepositoryBase) findOneByTitle(newsTitle string) (*newsEntity, error) {
	var (
		ent newsEntity
	)
	query := `SELECT content, continue, created_at, id, lead, title, updated_at FROM example.news WHERE title = $1`
	err := r.db.QueryRow(query, newsTitle).Scan(
		&ent.content,
		&ent.cont,
		&ent.createdAt,
		&ent.id,
		&ent.lead,
		&ent.title,
		&ent.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &ent, nil
}
func (r *newsRepositoryBase) findOneByTitleAndLead(newsTitle string, newsLead string) (*newsEntity, error) {
	var (
		ent newsEntity
	)
	query := `SELECT content, continue, created_at, id, lead, title, updated_at FROM example.news WHERE title = $1 AND lead = $2`
	err := r.db.QueryRow(query, newsTitle, newsLead).Scan(
		&ent.content,
		&ent.cont,
		&ent.createdAt,
		&ent.id,
		&ent.lead,
		&ent.title,
		&ent.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &ent, nil
}
func (r *newsRepositoryBase) insert(e *newsEntity) (*newsEntity, error) {
	insert := pqcomp.New(0, 7)
	insert.AddExpr(tableNewsColumnContent, "", e.content)
	insert.AddExpr(tableNewsColumnContinue, "", e.cont)
	insert.AddExpr(tableNewsColumnCreatedAt, "", e.createdAt)
	insert.AddExpr(tableNewsColumnLead, "", e.lead)
	insert.AddExpr(tableNewsColumnTitle, "", e.title)
	insert.AddExpr(tableNewsColumnUpdatedAt, "", e.updatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString(" RETURNING ")
			b.WriteString(strings.Join(r.columns, ", "))
		}
	}

	if r.dbg {
		if err := r.log.Log("msg", b.String(), "function", "Insert"); err != nil {
			return nil, err
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.content,
		&e.cont,
		&e.createdAt,
		&e.id,
		&e.lead,
		&e.title,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *newsRepositoryBase) upsert(e *newsEntity, p *newsPatch, inf ...string) (*newsEntity, error) {
	insert := pqcomp.New(0, 7)
	update := insert.Compose(7)
	insert.AddExpr(tableNewsColumnContent, "", e.content)
	insert.AddExpr(tableNewsColumnContinue, "", e.cont)
	insert.AddExpr(tableNewsColumnCreatedAt, "", e.createdAt)
	insert.AddExpr(tableNewsColumnLead, "", e.lead)
	insert.AddExpr(tableNewsColumnTitle, "", e.title)
	insert.AddExpr(tableNewsColumnUpdatedAt, "", e.updatedAt)
	if len(inf) > 0 {
		update.AddExpr(tableNewsColumnContent, "=", p.content)
		update.AddExpr(tableNewsColumnContinue, "=", p.cont)
		update.AddExpr(tableNewsColumnCreatedAt, "=", p.createdAt)
		update.AddExpr(tableNewsColumnLead, "=", p.lead)
		update.AddExpr(tableNewsColumnTitle, "=", p.title)
		update.AddExpr(tableNewsColumnUpdatedAt, "=", p.updatedAt)
	}

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() > 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
	}
	b.WriteString(" ON CONFLICT ")
	if len(inf) > 0 && update.Len() > 0 {
		b.WriteString(" (")
		for j, i := range inf {
			if j != 0 {
				b.WriteString(", ")
			}
			b.WriteString(i)
		}
		b.WriteString(") ")
		b.WriteString(" DO UPDATE SET ")
		for update.Next() {
			if !update.First() {
				b.WriteString(", ")
			}

			b.WriteString(update.Key())
			b.WriteString(" ")
			b.WriteString(update.Oper())
			b.WriteString(" ")
			b.WriteString(update.PlaceHolder())
		}
	} else {
		b.WriteString(" DO NOTHING ")
	}
	if insert.Len() > 0 {
		if len(r.columns) > 0 {
			b.WriteString(" RETURNING ")
			b.WriteString(strings.Join(r.columns, ", "))
		}
	}

	if r.dbg {
		if err := r.log.Log("msg", b.String(), "function", "Upsert"); err != nil {
			return nil, err
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.content,
		&e.cont,
		&e.createdAt,
		&e.id,
		&e.lead,
		&e.title,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *newsRepositoryBase) updateOneByID(id int64, patch *newsPatch) (*newsEntity, error) {
	update := pqcomp.New(1, 7)
	update.AddArg(id)

	update.AddExpr(tableNewsColumnContent, pqcomp.Equal, patch.content)
	update.AddExpr(tableNewsColumnContinue, pqcomp.Equal, patch.cont)
	if patch.createdAt != nil {
		update.AddExpr(tableNewsColumnCreatedAt, pqcomp.Equal, patch.createdAt)

	}
	update.AddExpr(tableNewsColumnLead, pqcomp.Equal, patch.lead)
	update.AddExpr(tableNewsColumnTitle, pqcomp.Equal, patch.title)
	if patch.updatedAt != nil {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, patch.updatedAt)
	} else {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, "NOW()")
	}

	if update.Len() == 0 {
		return nil, errors.New("news update failure, nothing to update")
	}
	query := "UPDATE example.news SET "
	for update.Next() {
		if !update.First() {
			query += ", "
		}

		query += update.Key() + " " + update.Oper() + " " + update.PlaceHolder()
	}
	query += " WHERE id = $1 RETURNING " + strings.Join(r.columns, ", ")
	var e newsEntity
	err := r.db.QueryRow(query, update.Args()...).Scan(
		&e.content,
		&e.cont,
		&e.createdAt,
		&e.id,
		&e.lead,
		&e.title,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &e, nil
}
func (r *newsRepositoryBase) updateOneByTitle(newsTitle string, patch *newsPatch) (*newsEntity, error) {
	update := pqcomp.New(1, 7)
	update.AddArg(newsTitle)
	update.AddExpr(tableNewsColumnContent, pqcomp.Equal, patch.content)
	update.AddExpr(tableNewsColumnContinue, pqcomp.Equal, patch.cont)
	if patch.createdAt != nil {
		update.AddExpr(tableNewsColumnCreatedAt, pqcomp.Equal, patch.createdAt)

	}
	update.AddExpr(tableNewsColumnLead, pqcomp.Equal, patch.lead)
	update.AddExpr(tableNewsColumnTitle, pqcomp.Equal, patch.title)
	if patch.updatedAt != nil {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, patch.updatedAt)
	} else {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, "NOW()")
	}

	if update.Len() == 0 {
		return nil, errors.New("news update failure, nothing to update")
	}
	query := "UPDATE example.news SET "
	for update.Next() {
		if !update.First() {
			query += ", "
		}

		query += update.Key() + " " + update.Oper() + " " + update.PlaceHolder()
	}
	query += " WHERE title = $1 RETURNING " + strings.Join(r.columns, ", ")
	if r.dbg {
		if err := r.log.Log("msg", query, "function", "UpdateOneByTitle"); err != nil {
			return nil, err
		}
	}
	var e newsEntity
	err := r.db.QueryRow(query, update.Args()...).Scan(
		&e.content,
		&e.cont,
		&e.createdAt,
		&e.id,
		&e.lead,
		&e.title,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &e, nil
}
func (r *newsRepositoryBase) updateOneByTitleAndLead(newsTitle string, newsLead string, patch *newsPatch) (*newsEntity, error) {
	update := pqcomp.New(2, 7)
	update.AddArg(newsTitle)
	update.AddArg(newsLead)
	update.AddExpr(tableNewsColumnContent, pqcomp.Equal, patch.content)
	update.AddExpr(tableNewsColumnContinue, pqcomp.Equal, patch.cont)
	if patch.createdAt != nil {
		update.AddExpr(tableNewsColumnCreatedAt, pqcomp.Equal, patch.createdAt)

	}
	update.AddExpr(tableNewsColumnLead, pqcomp.Equal, patch.lead)
	update.AddExpr(tableNewsColumnTitle, pqcomp.Equal, patch.title)
	if patch.updatedAt != nil {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, patch.updatedAt)
	} else {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, "NOW()")
	}

	if update.Len() == 0 {
		return nil, errors.New("news update failure, nothing to update")
	}
	query := "UPDATE example.news SET "
	for update.Next() {
		if !update.First() {
			query += ", "
		}

		query += update.Key() + " " + update.Oper() + " " + update.PlaceHolder()
	}
	query += " WHERE title = $1 AND lead = $2 RETURNING " + strings.Join(r.columns, ", ")
	if r.dbg {
		if err := r.log.Log("msg", query, "function", "UpdateOneByTitleAndLead"); err != nil {
			return nil, err
		}
	}
	var e newsEntity
	err := r.db.QueryRow(query, update.Args()...).Scan(
		&e.content,
		&e.cont,
		&e.createdAt,
		&e.id,
		&e.lead,
		&e.title,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &e, nil
}

func (r *newsRepositoryBase) deleteOneByID(id int64) (int64, error) {
	query := "DELETE FROM example.news WHERE id = $1"

	res, err := r.db.Exec(query, id)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const (
	tableComment                              = "example.comment"
	tableCommentColumnContent                 = "content"
	tableCommentColumnCreatedAt               = "created_at"
	tableCommentColumnID                      = "id"
	tableCommentColumnNewsID                  = "news_id"
	tableCommentColumnNewsTitle               = "news_title"
	tableCommentColumnUpdatedAt               = "updated_at"
	tableCommentConstraintNewsIDForeignKey    = "example.comment_news_id_fkey"
	tableCommentConstraintNewsTitleForeignKey = "example.comment_news_title_fkey"
)

var (
	tableCommentColumns = []string{
		tableCommentColumnContent,
		tableCommentColumnCreatedAt,
		tableCommentColumnID,
		tableCommentColumnNewsID,
		tableCommentColumnNewsTitle,
		tableCommentColumnUpdatedAt,
	}
)

type commentEntity struct {
	// content ...
	content string
	// createdAt ...
	createdAt time.Time
	// id ...
	id *ntypes.Int64
	// newsID ...
	newsID int64
	// newsTitle ...
	newsTitle string
	// updatedAt ...
	updatedAt *time.Time
	// newsByTitle ...
	newsByTitle *newsEntity
	// newsByID ...
	newsByID *newsEntity
}

func (e *commentEntity) prop(cn string) (interface{}, bool) {
	switch cn {
	case tableCommentColumnContent:
		return &e.content, true
	case tableCommentColumnCreatedAt:
		return &e.createdAt, true
	case tableCommentColumnID:
		return &e.id, true
	case tableCommentColumnNewsID:
		return &e.newsID, true
	case tableCommentColumnNewsTitle:
		return &e.newsTitle, true
	case tableCommentColumnUpdatedAt:
		return &e.updatedAt, true
	default:
		return nil, false
	}
}
func (e *commentEntity) props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// commentIterator is not thread safe.
type commentIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *commentIterator) Next() bool {
	return i.rows.Next()
}

func (i *commentIterator) Close() error {
	return i.rows.Close()
}

func (i *commentIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *commentIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper around comment method that makes iterator more generic.
func (i *commentIterator) Ent() (interface{}, error) {
	return i.Comment()
}

func (i *commentIterator) Comment() (*commentEntity, error) {
	var ent commentEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type commentCriteria struct {
	offset, limit int64
	sort          map[string]bool
	content       *qtypes.String
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	newsID        *qtypes.Int64
	newsTitle     *qtypes.String
	updatedAt     *qtypes.Timestamp
}

func (c *commentCriteria) WriteComposition(sel string, com *pqtgo.Composer, opt *pqtgo.CompositionOpts) (err error) {

	if err = pqtgo.WriteCompositionQueryString(c.content, tableCommentColumnContent, com, pqtgo.And); err != nil {
		return
	}

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return err
			}
			switch c.createdAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableCommentColumnCreatedAt)
					com.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							com.WriteString(", ")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableCommentColumnCreatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(createdAt1)
					com.WriteString(" AND ")
					com.WriteString(tableCommentColumnCreatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(createdAt2)
				}
			}
		}
	}

	if err = pqtgo.WriteCompositionQueryInt64(c.id, tableCommentColumnID, com, &pqtgo.CompositionOpts{
		Joint:  " AND ",
		IsJSON: false,
	}); err != nil {
		return
	}

	if err = pqtgo.WriteCompositionQueryInt64(c.newsID, tableCommentColumnNewsID, com, &pqtgo.CompositionOpts{
		Joint:  " AND ",
		IsJSON: false,
	}); err != nil {
		return
	}

	if err = pqtgo.WriteCompositionQueryString(c.newsTitle, tableCommentColumnNewsTitle, com, pqtgo.And); err != nil {
		return
	}

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return err
			}
			switch c.updatedAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableCommentColumnUpdatedAt)
					com.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							com.WriteString(", ")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableCommentColumnUpdatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(updatedAt1)
					com.WriteString(" AND ")
					com.WriteString(tableCommentColumnUpdatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(updatedAt2)
				}
			}
		}
	}

	if len(c.sort) > 0 {
		i := 0
		com.WriteString(" ORDER BY ")

		for cn, asc := range c.sort {
			for _, tcn := range tableCommentColumns {
				if cn == tcn {
					if i > 0 {
						com.WriteString(", ")
					}
					com.WriteString(cn)
					if !asc {
						com.WriteString(" DESC ")
					}
					i++
					break
				}
			}
		}
	}
	if c.offset > 0 {
		if _, err = com.WriteString(" OFFSET "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.offset)
	}
	if c.limit > 0 {
		if _, err = com.WriteString(" LIMIT "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.limit)
	}

	return
}

type commentPatch struct {
	content   *ntypes.String
	createdAt *time.Time
	id        *ntypes.Int64
	newsID    *ntypes.Int64
	newsTitle *ntypes.String
	updatedAt *time.Time
}

type commentRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func scanCommentRows(rows *sql.Rows) ([]*commentEntity, error) {
	var (
		entities []*commentEntity
		err      error
	)
	for rows.Next() {
		var ent commentEntity
		err = rows.Scan(
			&ent.content,
			&ent.createdAt,
			&ent.id,
			&ent.newsID,
			&ent.newsTitle,
			&ent.updatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *commentRepositoryBase) count(c *commentCriteria) (int64, error) {

	com := pqtgo.NewComposer(6)
	buf := bytes.NewBufferString("SELECT COUNT(*) FROM ")
	buf.WriteString(r.table)

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return 0, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	if err := r.db.QueryRow(buf.String(), com.Args()...).Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

func (r *commentRepositoryBase) find(c *commentCriteria) ([]*commentEntity, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return scanCommentRows(rows)
}
func (r *commentRepositoryBase) findIter(c *commentCriteria) (*commentIterator, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	return &commentIterator{rows: rows}, nil
}
func (r *commentRepositoryBase) insert(e *commentEntity) (*commentEntity, error) {
	insert := pqcomp.New(0, 6)
	insert.AddExpr(tableCommentColumnContent, "", e.content)
	insert.AddExpr(tableCommentColumnCreatedAt, "", e.createdAt)
	insert.AddExpr(tableCommentColumnNewsID, "", e.newsID)
	insert.AddExpr(tableCommentColumnNewsTitle, "", e.newsTitle)
	insert.AddExpr(tableCommentColumnUpdatedAt, "", e.updatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString(" RETURNING ")
			b.WriteString(strings.Join(r.columns, ", "))
		}
	}

	if r.dbg {
		if err := r.log.Log("msg", b.String(), "function", "Insert"); err != nil {
			return nil, err
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.content,
		&e.createdAt,
		&e.id,
		&e.newsID,
		&e.newsTitle,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *commentRepositoryBase) upsert(e *commentEntity, p *commentPatch, inf ...string) (*commentEntity, error) {
	insert := pqcomp.New(0, 6)
	update := insert.Compose(6)
	insert.AddExpr(tableCommentColumnContent, "", e.content)
	insert.AddExpr(tableCommentColumnCreatedAt, "", e.createdAt)
	insert.AddExpr(tableCommentColumnNewsID, "", e.newsID)
	insert.AddExpr(tableCommentColumnNewsTitle, "", e.newsTitle)
	insert.AddExpr(tableCommentColumnUpdatedAt, "", e.updatedAt)
	if len(inf) > 0 {
		update.AddExpr(tableCommentColumnContent, "=", p.content)
		update.AddExpr(tableCommentColumnCreatedAt, "=", p.createdAt)
		update.AddExpr(tableCommentColumnNewsID, "=", p.newsID)
		update.AddExpr(tableCommentColumnNewsTitle, "=", p.newsTitle)
		update.AddExpr(tableCommentColumnUpdatedAt, "=", p.updatedAt)
	}

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() > 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
	}
	b.WriteString(" ON CONFLICT ")
	if len(inf) > 0 && update.Len() > 0 {
		b.WriteString(" (")
		for j, i := range inf {
			if j != 0 {
				b.WriteString(", ")
			}
			b.WriteString(i)
		}
		b.WriteString(") ")
		b.WriteString(" DO UPDATE SET ")
		for update.Next() {
			if !update.First() {
				b.WriteString(", ")
			}

			b.WriteString(update.Key())
			b.WriteString(" ")
			b.WriteString(update.Oper())
			b.WriteString(" ")
			b.WriteString(update.PlaceHolder())
		}
	} else {
		b.WriteString(" DO NOTHING ")
	}
	if insert.Len() > 0 {
		if len(r.columns) > 0 {
			b.WriteString(" RETURNING ")
			b.WriteString(strings.Join(r.columns, ", "))
		}
	}

	if r.dbg {
		if err := r.log.Log("msg", b.String(), "function", "Upsert"); err != nil {
			return nil, err
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.content,
		&e.createdAt,
		&e.id,
		&e.newsID,
		&e.newsTitle,
		&e.updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}

/// SQL ...
const SQL = `
-- do not modify, generated by pqt

CREATE SCHEMA IF NOT EXISTS example; 

CREATE TABLE IF NOT EXISTS example.category (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	name TEXT NOT NULL,
	parent_id BIGINT,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.category_id_pkey" PRIMARY KEY (id),
	CONSTRAINT "example.category_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES example.category (id)
);

CREATE TABLE IF NOT EXISTS example.package (
	break TEXT,
	category_id BIGINT,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.package_category_id_fkey" FOREIGN KEY (category_id) REFERENCES example.category (id),
	CONSTRAINT "example.package_id_pkey" PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS example.news (
	content TEXT NOT NULL,
	continue BOOL DEFAULT false NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	lead TEXT,
	title TEXT NOT NULL,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.news_id_pkey" PRIMARY KEY (id),
	CONSTRAINT "example.news_title_key" UNIQUE (title),
	CONSTRAINT "example.news_title_lead_key" UNIQUE (title, lead)
);

CREATE TABLE IF NOT EXISTS example.comment (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	news_id BIGINT NOT NULL,
	news_title TEXT NOT NULL,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.comment_news_id_fkey" FOREIGN KEY (news_id) REFERENCES example.news (id),
	CONSTRAINT "example.comment_news_title_fkey" FOREIGN KEY (news_title) REFERENCES example.news (title)
);

`
